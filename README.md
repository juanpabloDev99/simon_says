% A Simon Says project for a Zynq Pynq Z2 using VHDL
% juan pablo davila
% 

\section{General Overview}

The principal entity named Simon orchestrates the flow of signals among a series of submodules:

\begin{itemize}
  \item Game Logic (game): Determines whether the user input is correct and whether the round is completed successfully or in error.
  \item Print Logic (print): Handles the process of showing the sequence or result on LEDs or other visual outputs.
  \item Random Sequence Generator (random): Produces pseudo-random data used to decide which button/lamp is next in the sequence.
  \item Timing Modules (timer): Provide accurate delays or time-based expiration signals for different actions in the game.
  \item Input Debounce   (debounceFilter ): Clean up or validate user inputs against switch “bouncing” in hardware.
  \item Decoder and Selector Components (decoder, selectWord, word2button, etc.): Transform and route signals to the correct destinations for display or internal comparison.
  \item Auxiliary Components (keepCycles, onePulseControl): Provide signal-latching, or cyclical hold functionalities.
\end{itemize}

All these parts work together under a shared clock and reset, taking advantage of generics to be adaptable to different operating frequencies, timing delays, or game settings.
\\

\section{Top-Level Entity: simon}

The simon entity is the highest-level module that uses generics to set parameters such as clock frequency, number of game and print seconds, waiting fractions for timing, and a seed for random generation. It includes declarations of various internal signals that hold status codes, round counters, random sequences, or the state of user input. The key signals, for instance status, help track the main state of the game, distinguishing among scenarios like waiting in idle mode, printing a sequence, playing the round, or indicating a win/lose outcome.
\\

Inside the simon architecture, processes and concurrent assignments define the main control flow:

\begin{itemize}
  \item Status Register: A process monitors reset, clk, and the current status. It transitions among states such as STATUS_VOID (idle), STATUS_PRINT, STATUS_GAME, STATUS_WIN, and STATUS_LOOSE. These symbolic constants are encoded in three bits and determine what the hardware should do next.
  \item Round Counter: Another signal, round, increments whenever the user successfully completes a sequence, or resets when the user restarts or fails.
  \item Buttons: Raw button inputs (botones) are conditionally routed through a buttonsInterface submodule to remove bouncing effects. The final corrected button signals are then used by the game and print entities.
  \item Random: The random_sequence is continuously generated by the random entity. A small process decides when to enable or reset it (for example, clearing it after a game ends).
  \item Outputs: The module drives leds and segments, as well as a four-bit selector that indicates which button or LED is currently active.
\end{itemize}

Because this is a synchronous design, almost all behavior is activated by a rising_edge(clk) statement in processes, though asynchronous resets ensure that the design returns to a stable initial state whenever reset is asserted.
\\
 
\section{Timing and Control Submodules}

\subsection{The timer Entity}

A critical part of this design is the ability to measure elapsed time or determine if a certain duration has passed. The timer entity uses a counter of a fixed size to compare against a target value computed from a generic CLOCK_FREQ multiplied by a generic SECONDS. Once the internal counter matches or exceeds the target, the expired signal is asserted.
Within its architecture:

\begin{itemize}
  \item A 30-bit counter accumulates clock cycles.
  \item A target is computed using to_unsigned(CLOCK_FREQ * SECONDS, 30).
  \item Each clock cycle, if the timer has not expired and the clear signal is not asserted, the counter increments; otherwise, it resets or sets expired.
\end{itemize}

This timer is used in several places (e.g., inside lights, game, or simon) to regulate intervals such as how long a sequence should remain lit, how long to wait between steps, and how long a user is allowed to respond.
\\

\subsection{The keepCycles Entity}

Another timing-related utility is keepCycles, in which a signal is forced high for a specified number of clock cycles. Its internal finite-state machine (FSM) transitions among states IDLE, SET_ON, and SET_OFF. In IDLE, it waits for an input trigger (d = '1'). Once triggered, it moves to SET_ON, sets the output q to '1', and starts counting. When the count reaches a generic maximum KEEP_CYCLES, the FSM transitions to SET_OFF and lowers q again. The design resets if the input goes low or a separate clear or reset is asserted.
\\

This is especially useful for edge detection or short-term hold of a signal, ensuring that certain pulses last long enough to be recognized elsewhere in the circuit.
\\

\section{Input and Sequence Generation}

\subsection{Debouncing and Filtering: debounceFilter and buttonsInterface}

Physical switches often exhibit mechanical noise or “bouncing” when toggled. The debounceFilter module captures an input pulse, holds an internal counter if bouncing is detected, and only asserts its output after a stable period. In its architecture, there is a small state machine that looks at transitions of the input signal, clearing or incrementing a counter until the signal is deemed stable.

Similarly, buttonsInterface in the simon module references debounceFilter-like behavior by cleaning all four input buttons. It ensures the game logic only receives valid on/off transitions that do not oscillate rapidly.
\\

\subection{Random Number Generation: random}

In many games, unpredictability is a key part of the user experience. Here, the random module is a linear-feedback shift register (LFSR) that uses the generics SEED to determine its initial state. Each clock cycle, if enable is '1', the register shifts and the new most significant bit is computed as the XOR of several taps (aux_seq(15) XOR aux_seq(13) XOR aux_seq(12) XOR aux_seq(10)). By toggling enable or asserting clear, the design either advances the pseudo-random sequence or resets it to SEED.
\\

Internally, the LFSR approach is straightforward:

\begin{enumerate}
  \item A process runs on the rising edge of the clock.
  \item If reset is high, the register is set back to the seed.
  \item Otherwise, if clear is high, it also resets to the seed.
  \item If enable is high, the shift with feedback occurs.
\end{enumerate}

This sequence is used in the game logic to generate the next button or light that the user must match.
\\

\section{Game Logic and Sequence Display}

\subsection{The game Entity}

The game module supervises each round’s correctness. It does so by comparing user button inputs to the expected sequence and by monitoring a timer subcomponent for user timeouts. Its internal signals (done and error) are set when:

\begin{itemize}
  \item The user presses the correct button (sets done high).
  \item The user presses the wrong button or the time expires (sets error high).
\end{itemize}

The logic is sensitive to a “round” number, which dictates how many correct presses the user must make in a sequence. Within the architecture:

\begin{itemize}
  \item A subcomponent timer named u_timer tracks time. If it expires and the user has not pressed the correct button, an error is triggered.
  \item Another subcomponent selectWord picks the correct pattern (four-bit wide) from the random sequence based on the current round.
  \item A final subcomponent singleButtonGame compares the actual user presses to the expected button combination. If they match, done becomes '1', otherwise error is asserted.
\end{itemize}

When done is '1', the main simon logic increments the round counter until a maximum is reached, at which point the user “wins.” If error is asserted, the user “loses” and the system transitions to a fail state.
\\

\subection{The print Entity}

Displaying the sequence and final results is handled by the print module, which coordinates between a lights subcomponent and a decoder:

\begin{itemize}
  \item lights systematically shows each “word” (which in this design is a specific button or LED pattern) for a short interval, waits, then moves on. It uses multiple timer instances internally to ensure the correct pacing: one for the “print” time, another for the “wait” time, and a final one for the “sentence” time if the user has won or lost.
  \item decoder translates a minimal control signal (01, 10, 11) to a seven-segment pattern representing distinct letters or digits (for instance, “8” for printing, “E” for error, and “0” for loose). The segments output can be used by a display device to visually differentiate states like “print,” “win,” or “lose.”
\end{itemize}

Within the print architecture, a signal named status from the top-level defines which scenario is being displayed:

\begin{itemize}
  \item status(1 downto 0) = "01" might mean a sequence is being printed (PRINT_SEQ internally),
  \item status(1 downto 0) = "10" could reflect a “win” state,
  \item status(1 downto 0) = "11" might display a “lose” state.
\end{itemize}

Each sub-state triggers a specific time-based operation inside lights, eventually asserting finished to indicate the cycle is complete.
\\

\section{Additional Supporting Components}

Beyond the major building blocks, smaller helper entities appear throughout the code:

\begin{itemize}
  \item onePulseControl: Generates a single clock-cycle-wide pulse in response to an input transition, useful for debounced signals or capturing the rising edge of a button press.
  \item selectWord: Chooses a 4-bit word from a 16-bit random sequence by referencing a small integer index. Each pair of bits from the random vector selects one of four outputs, which is turned into a one-hot pattern ("1000", "0100", "0010", or "0001").
  \item singleButtonGame: A minimal entity that determines if a single button press is correct. It detects a match between buttons and the word it expects, sets done if correct, or error if incorrect or if the timer signal is asserted. It is used inside the main game entity for verifying each user press.
\end{itemize}

These modules each address small, well-defined tasks, making the overall design more modular and clearer to maintain.
\\

\section{Concluding Remarks}

In summary, this VHDL-based project is an exercise in digital design that involves a hierarchical arrangement of submodules. At the highest level, simon coordinates user input, pseudo-random sequence generation, game-state tracking, and visible feedback. It carefully manages transitions between states such as idle, printing a sequence, checking the user’s button press in the game, and indicating either a successful completion or a failing outcome. The system uses standard synchronous design principles: each submodule is clocked by the same global clock, and asynchronous resets bring the entire circuit into a known state when needed.
\\

All timing is performed by comparing counters to computed targets, ensuring that the modules remain as generic and reusable as possible. By changing the generics—such as CLOCK_FREQ, GAME_SECONDS, or SENTENCE_SECONDS—one can alter how long the user has to respond, how quickly the sequence is displayed, or even adapt the design to different clock speeds. Meanwhile, the presence of modules like debounceFilter and random ensure robust, noise-free inputs and unpredictable sequences, respectively.
\\

This decomposition into multiple entities offers clarity and testability: each piece (e.g., timer or singleButtonGame) can be validated in isolation, improving reliability of the integrated system. When synthesized on an FPGA or other programmable logic device, the user would see a straightforward hardware game that prompts them to follow flashing lights in a repeatable sequence, awarding a “win” if they succeed over several rounds.
 
 
